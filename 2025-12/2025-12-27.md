# [2025-12-27] 파이썬 과제
## 오늘의 목표 (Scrum)

> 파이썬 과제 완료하기

## 배운 내용 (Today I Learned)

### 변수와 자료형 (int, float, str, bool, list, dict, tuple, set)

- 개요
- python은 동적 타이핑 언어로, 변수를 선언할 때 타입을 명시하지 않아도 실행 시점에 자동으로 결정된다. 모든 자료형은 객체(Object)로 취급된다.
  - 동적 타이핑과 반대되는 개념으로 변수의 자료형을 컴파일 시점에 결정하는 방식도 있다.
  - 변수를 선언할 때는 반드시 자료형을 명시해야 하며, 한 번 결정된 타입은 변경할 수 없다.
    - C,C++,Java...
  - 컴파일 시점에 타입 오류를 잡아내어 안정성이 높으며, 실행 시 타입 체크를 하지 않아 빠르다.
    ```
      int age = 25; // 선언 시점에 타입을 명시
      age = "25" // int형에 다른 자료형을 대입하므로 대입 불가
    ```
### 기본 자료형
- int(integer): 정수를 표현한다. (Pyhon3에서는 정수 크기에 제한이 없어졌다.)
- float: 소수점이 표현된 실수를 말한다. (부동 소수점 오차가 발생할 수 있다.)
```
name = "Python"
greeting = 'Hello'
```
- 문자열 (str): 문자들의 집합, 불변 자료형 '' 작은 따옴표 혹은 "" 큰 따옴표를 사용한다.
```
  name = "Python"
  greeting = 'Hello'
```
- 불리언 (bool) : 논리 값인 True와 False를 나타냄
```
  1 == 1 // True
  2 < 1 // False
```
### 컨테이너 자료형
- 리스트: 순서가 있고, 수정이 가능한 자료형
- 동일하거나 다른 타입의 데이터를 일렬로 관리할 때 사용한다. (파이썬의 리스트는 연결 리스트가 아닌 동적 배열임)
```
  fruits = ["apple","banan","cherry"]
  fruits[0] = "grape" 
```
- 튜플: 순서가 있지만, 수정이 불가능한 자료형
- 데이터의 값이 변하지 않아야 하거나 함수의 리턴값으로 여러 개를 반환할 때 주로 사용한다.
```
  tuple_test = (10,20)
  tuple_test[0] =5 # Error 발생 불변이여야 하므로
```
- 딕셔너리(dict): 키(key)와 값(value)의 쌍으로 이루어진 해시 맵 구조
- 연관된 데이터를 키를 통해 빠르게 검색해야 할 때 사용한다.
```
  user = {"name":"Kim","major":"cs"}
  print(user["name"]) # kim
```
- 집합(set): 중복을 허용하지 않으며, 순서가 없다.
- 중복을 제거하거나, 합집합/교집합 등의 집합 연산에 최적화되어 있다.

``` python
  numbers = {1, 2, 2, 3}  # {1, 2, 3}으로 저장됨
  A = {1, 2, 3, 4, 5}
  B = {4, 5, 6, 7, 8}

  print(A | B)  # 합집합: {1, 2, 3, 4, 5, 6, 7, 8} 
  print(A & B)  # 교집합: {4, 5} 
  print(A - B)  # 차집합: {1, 2, 3} 
```
---
### 조건문과 반복문 (if, for, while)
- 파이썬의 조건문은 if,elif,else 구조를 가진다.
- 프로그램 흐름을 조건에 따라 나누는 가장 기본적인 제어문이다.
  - 파이썬은 단락 평가(Short-circuit Evaluation)을 사용한다.
```python
score = 85
if score >= 90:
    print"A 학점")
elif score >= 80:
    print("B 학점")
else:
    print("C 학점 이하")
```
```python
  #단락 평가
  # A가 True이면 B를 확인하지 않는 특성 활용
  def expensive_call():
      print("복잡한 연산 수행 중...")
      return True
  
  if True or expensive_call():  # "복잡한 연산..."이 출력되지 않음
      print("단락 평가 덕분에 실행 속도 향상")
```
- 파이썬의 반복문은 다음과 같다.

```python
# for문
fruits = ["사과", "바나나", "포도"]
for fruit in fruits:
    print(f"내가 좋아하는 과일은 {fruit}")

# while문: 조건 반복
count = 0
while count < 3:
    print(f"{count}번 실행")
    count += 1
```

- 파이썬의 입출력은 다음과 같다.
``` python
  name = input("이름을 입력하세요: ")
  print("환영합니다,", name)
```
- 함수 (def)
- 반복되는 코드를 하나로 묶어 가독성 있게 사용할 때 사용함
- *args: 여러 개의 인자를 튜플로 묶어서 받는다.
- **kwargs: 키워드와 값의 쌍 (key=value)을 딕셔너리로 묶어서 받는다.  
```
  def greet(user):
    return f"안녕하세요, {user}님!"
    message = greet("영우")
    print(message)
```

```python
  def student(*subjects,**details):
      print(f"수강 과목: {subjects}") # ('자료구조', '알고리즘')
      print(f"학생 정보: {details}")  # {'name': '규태', 'major': 'CS'}
  student('자료구조,'알고리즘',name='규태',major='cs')
```
- 클래스란 객체를 만들기 위한 설계도 혹은 틀을 말한다. 어떤 데이터를 가지고 어떤 동작을 할지를 정의한다.
- 인스턴스란 설계도를 바탕으로 실제 메모리에 할당된 실체이다. 하나의 클래스 여러 개의 서로 다른 인스턴스를 만들 수 있다.
  - __init__ (생성자)
    - 인스턴스가 생성될 때 자동으로 호출되는 특수 메서드
    - 객체의 초기 상태(데이터)를 설정하는 역할을 한다.
   - __self__ (인스턴스 자기 자신)
    - 메서드를 정의할 때 첫 번째 인자로 self를 써주어야 함
    - 즉 현재 메서드를 호출한 인스턴스의 메모리 시작 주소를 받아온다.
- 클래스 변수: 클래스 하단에 선언되며, 모든 인스턴스가 하나의 메모리 주소를 공유한다.
- 인스턴스 변수: 각 객체마다 별도의 메모리 공간을 가진다.

- 네임스페이스(Namespace)와 __dict__
  - 정의: 변수 이름과 객체를 연결하여 관리하는 딕셔너리 구조의 이름 공간이다.
  
  - __dict__ 속성: 파이썬의 클래스와 인스턴스는 각자의 네임스페이스를 __dict__라는 딕셔너리에 저장한다.
  
  - 속성 탐색 원리: 특정 속성(변수나 메서드)을 호출하면 파이썬은 다음 순서로 이름을 탐색한다.
  - 인스턴스 __dict__: 객체 고유의 데이터가 있는지 확인 
  - 클래스 __dict__: (없다면) 공용 메서드나 클래스 변수가 있는지 확인
  - 부모 클래스: (상속 시) 상위 클래스로 거슬러 올라가며 탐색

  - 매직 메서드 (Magic Methods / Special Methods)
    - 정의: 클래스 내부에 정의된 이름 앞뒤에 언더바 두 개(__)가 붙은 특수 메서드이다.
    - 특징: 개발자가 직접 호출하기보다, 특정 상황(연산, 출력 등)에서 파이썬 인터프리터에 의해 자동으로 호출된다.
  - 주요 예시:
    - __init__: 객체 생성 시 초기화
    - __str__: print() 함수 호출 시 객체를 문자열로 어떻게 표현할지 결정
    - __add__: + 연산자가 사용될 때 실행될 동작 정의
```
  class Robot:
    population = 0  # 클래스 변수 

    def __init__(self, name, power):
        self.name = name    # 인스턴스 변수 
        self.power = power
        Robot.population += 1

    # print(객체) 호출 시 자동으로 실행되는 매직 메서드
    def __str__(self):
        return f"로봇 이름: {self.name} (전투력: {self.power})"

    # 객체 간 '+' 연산 시 실행되는 매직 메서드
    def __add__(self, other):
        return self.power + other.power

    r1 = Robot("건담", 100)
    r2 = Robot("자쿠", 80)
    
    # 네임스페이스 확인
    print(r1.__dict__)  # {'name': '건담', 'power': 100}
    
    # 매직 메서드 동작 확인
    print(r1)           # __str__ 호출 결과 출력
    print(r1 + r2)      # __add__ 호출 결과 출력 (180)
```
- 메서드 오버라이딩이란 부모 클래스에서 이미 정의된 메서드를 자식 클래스에서 다시 재정의하는 것
  - 상속 관계가 필수이며, 메서드 이름과 매개변수가 부모와 동일해야 한다.
```python
  class Computer:
    def power_on(self):
        print("시스템 부팅을 시작합니다.")

  class GamingLaptop(Computer):
      # 오버라이딩: 부모의 power_on을 자식에 맞게 재정의
      def power_on(self):
          # 자식 클래스에서 부모 클래스의 메서드나 속성에 접근할 떄 super() 사용
          # 부모 클래스에 power_on() 메서드도 실행한다.
          super().power_on()
          print("그래픽 카드를 활성화하고 LED 전원을 켭니다.")
  my_pc = GamingLaptop()
  my_pc.power_on()
```
### 고정 정밀도와 임의 정밀도
  - 보통 C나 Java 에서는 정수형을 저장할 때 4바이트(32비트) 혹은 8바이트(64비트)라는 고정된 할당 메모리 공간을 사용함
  - 고정 정밀도에서는 32bit의 경우 int형이 표현할 수 있는 최대값은 약 21억, 이 범위를 넘어가면 오버플로우가 발생함
  - Python3에서는 임의 정밀도를 지원해서 숫자의 크기에 따라 메모리를 가변적으로 사용함, 즉 숫자가 커지면 파이썬이 알아서 메모리를 더 할당해서 숫자를 작성
     - 임의 정밀도를 간략하게 설명하자면 2의 30승 단위를 기준으로, 값이 커질 때마다 4비트씩 메모리를 더 할당하여 더해줌으로써 메모리가 허용하는 최대한의 정수를 표현한다.
 ---
### 부동 소수점 오차란
  - 부동 소수점 오차란 실수를 컴퓨터 메모리 상에서 저장하는 과정에서 발생하는 미세한 값의 차이를 말한다.
  - 컴퓨터는 모든 데이터를 0과 1로 처리하는데 10진수 소수 중 일부는 2진수로 변환할 때 무한 소수가 됨
  - 메모리 공간은 유한하므로 컴퓨터는 무한한 자릿수를 저장할 수 없으므로 특정 지점에서 숫자를 자르거나 반올림함 이 과정에서 실제값과 차이가 발생함
    - 위 오류를 피하기 위해서는 decimal 모듈을 사용하거나 round() 함수를 통해 특정 소수점 자리에서 반올림하여 오차를 제거해야 한다.
--- 
### 문자열은 왜 불변형인가?
<img width="800" height="450" alt="image" src="https://github.com/user-attachments/assets/7f606a5e-983d-44b9-8050-dcd4d8a0242d" />

  - **String Interning (문자열 인터닝)**
  - 메모리를 아끼기 위해 똑같은 내용 문자열이 여러 번 생성되면 이를 각각 메모리에 올리지 않고 하나의 메모리 주소만 재사용한다.
    - 만약 문자열이 가변이게 되면 여러 변수가 같은 문자열 주소를 가리키고 있을 때 그 변수의 문자가 바뀌게 되면 문자열을 참조하고 있던 다른 변수들도 모두 값이 바뀌게 된다.이를 방지하기 위해 불변으로 고정
    - 멀티 스레드 환경에서도 여러 스레드가 동시에 같은 문자열을 참조하더라도, 내용이 변하지 않으므로 별도의 동기화 처리 없이 안전한게 데이터가 공유 가능하다.
---
### 파이썬은 연결 리스트가 아닌 동적 배열이라는게 무슨 말인가?
<img width="1400" height="613" alt="image" src="https://github.com/user-attachments/assets/e9efe040-aeb6-48f1-b287-6d6a30311ddb" />

  - 파이썬의 리스트는 데이터 자체를 직접 들고 있는게 아닌 데이터 객체가 저장된 메모리의 주소(Pointer)를 순서대로 저장하고 있음
  - 주소값들이 메모리상에 연속적으로 배치되어 있기 때문에 인덱스만 알면 즉시 해당 주소로 찾아갈 수 있음
  - 메모리상에 연속적으로 주소값이 배치되므로 한 리스트안에 int,str,list등 서로 다른 자료형이 들어갈 수 있음
    - 추가로 리스트는 데이터를 추가할 할 때마다 새로운 메모리를 할당받으면 비효율적이게 됨
    - 이를 방지하기 위해 Over-allocation 전략을 사용함 (오버 할당), 리스트가 꽉 차면, 현재 필요한 크기보다 좀 더 (1.15~1.2배)에 공간을 할당받음
---
### 딕셔너리에 해시 맵은 무엇인가?
<img width="1280" height="773" alt="image" src="https://github.com/user-attachments/assets/6213a3c5-6ab6-41a4-8deb-40fecbab351f" />

- 해시맵은 Key(키)를 해시 함수라는 수식에 통과시켜 나온 결과값을 배열의 인덱스로 사용하는 것
  - 즉 데이터를 찾을 때 모든 데이터를 뒤지는게 아니라 하나의 결과값을 이용해 단번의 위치를 찾아내는 것 이다.
    - 예를 들어 {"Kim":"aws"}라는 데이터를 저장한다고 가정하자
    - "Kim"을 해시 함수에 넣게 되면 (hash("kim")) -> 결과값으로 엄청나게 큰 정수가 나오게 됨 (예:57321)
    - 이 숫자를 현재 준비된 메모리 자료형의 크기로 나눈 나머지 (모듈러:%)를 구한다. -> 57321 % 8 = 1
    - 이제 메모리에 1번 칸에 "aws"라는 값을 저장한다.
    - 나중에 "Kim"이 무엇을 배우고 있는지 확인하려면 똑같은 계산 과정을 거쳐 바로 1번 칸으로 위치를 찾을 수 있다.
- 해시맵에서 가장 중요한 점은 **똑같은 키를 넘으면 항상 똑같은 결과 값이 나와야 한다는 것**
  - 만약 값이 변하는 리스트를 키로 썻는데 내부 값이 바뀌어버리면 해시의 결과도 다르게 바뀌어 저장된 데이터를 찾을 수 없게된다.
  - 그래서 딕셔너리의 키는 **불변(Immutable) 자료형**으로만 사용해야 한다.
---
### 해시 충돌이란?
<img width="1280" height="798" alt="image" src="https://github.com/user-attachments/assets/fe284b15-9ad4-486c-8509-41b437ee6e0c" />

- 간혹 서로 다른 두 키에 대한 동일한 인덱스를 반환하는 경우가 있는게 이를 **해시 충돌**이라고 한다.
- 해결 방법으로는 개방 주소법, 분리 연결법이 있는데 파이썬에서는 개방 주소법을 사용한다.
  - 개방 주소법은 해시 충돌 발생 시 배열 내부의 다른 빈 슬롯을 찾아 데이터를 저장하는 방식이다.
  - 탐사 규칙(선형, 이차, 이중 해시)에 따라 성능이 달라지며, 추가 메모리 없이 배열의 연속성을 활용해 캐시 효율을 극대화할 수 있는 것이 특징이다.
 ---
### 왜 Set은 중복을 허용하지 않고 순서가 없는가?
- 답은 간단한데 Set 또한 해시 함수를 사용하기 때문이다.
- 왜 Hash Table을 사용하냐고 하면 **"중복 확인", "존재 확인"**의 속도 때문이다.
  - 만약 리스트에서 값을 찾게 되면 첫 번째 주소부터 마지막 주소까지 전부 찾아야 함
  - 그러나 해시 테이블을 사용하게 되면 데이터가 10억개 있더라도 O(1)의 속도로 데이터를 찾을 수 있게 된다.
- 만약 값 10을 넣으려고 하면 hash(10)을 통해 특정 칸 (예:5번칸)에 넣게 됨
- 또 다른 10을 넣으려고 하면 hash(10)을 통해 5번칸에 넣게 되는데 이미 데이터가 있는 것을 확인하고 중복이 자동으로 제거 됨
- Set은 해시 함수가 정해주는 주소에 따라 저장하게 됨, 즉 1,2,3 순서로 넣어도 출력 결과는 뒤죽박죽이게 된다.
  - Set또한 해시 함수를 사용하므로 자료형이 불변이여야 함
---
### 단락 평가가 무엇인가?
<img width="804" height="884" alt="image" src="https://github.com/user-attachments/assets/d6e4b4d9-51b1-4595-a87f-38e9dd3009e9" />

- 단락 평가는 논리 연산을 수행할 때, 첫 번째 값만으로 전체 결과가 확실해지면 두 번째 값은 확인하지 않고 계산을 끝내는 방식
- 즉 불필요한 연산을 하지 않아도 되므로 성능이 더 올라가게 된다.
---
### 파이썬의 range()는 lazy evaluation이다.
- list(range(1,000,000))을 사용하게 되면 1번 부터 100만번까지의 정수를 모두 메모리에 담아두어야 한다. (메모리 효율성 매우 떨어짐)
- 그러나 range()의 경우 내부적으로 모든 숫자를 다 저장하는게 아닌 세 가지 정보만 저장하게 된다.
  - start: 어디서 시작하는가
  - stop: 어디서 끝나는가
  - step: 얼마씩 증가하는가
  - 즉 숫자가 필요할 때 마다 즉석에서 계산하는 지연 평가 방식이다. 데이터가 아무리 많아도 O(1)의 속도로 판단한다.
```python
  import sys

  # 100만 개의 숫자를 다루는 두 방식의 메모리 크기 비교
  r = range(1000000)
  l = list(range(1000000))
  
  print(f"range 객체 메모리: {sys.getsizeof(r)} bytes") # 48 bytes (규칙만 저장)
  print(f"list 객체 메모리: {sys.getsizeof(l)} bytes")  # 약 8,000,000 bytes (모든 숫자 저장)
```

### 파이썬은 인자 (매개변수)를 전달할 때 Pass by Object Reference를 사용한다
- 가변 객체 (list,dict,set)을 넘길 때는 Call by Reference 처럼 작동한다.
  -  함수 내부의 매개 변수가 외부의 객체와 똑같은 메모리 주소를 가리킨다.
  -  함수 내부에서 객체 자체를 수정할 때 함수 밖의 원본 데이터도 변하게 된다.
```
  def modify_list(li):
    li.append(4)  # 같은 주소의 객체에 값을 추가함
    print(f"함수 내부: {li}, 주소: {id(li)}")

    my_list = [1, 2, 3]
    modify_list(my_list)
    print(f"함수 외부: {my_list}, 주소: {id(my_list)}")

    # 결과: 함수 내부와 외부의 주소가 같고, 외부 리스트도 [1, 2, 3, 4]로 변함
```

- 불변 객체를 넘길 때는 마치 Call by Value로 동작하는 것 처럼 보이게 된다.
  - 처음에는 같은 주소를 가리키지만, 함수 내부에서 값을 바꾸려고 하면 새로운 객체가 생성되어 매개변수가 그 주소를 가리키게 됨
  - 함수 내부에서 아무리 값을 바꾸어도 함수 밖의 원본 객체는 바뀌지 않는다.
```python
  def modify_int(n):
    n = n + 10  # 새로운 정수 객체(기존값+10)를 만들고 n이 거기를 가리키게 함
    print(f"함수 내부: {n}, 주소: {id(n)}")

    my_num = 10
    modify_int(my_num)
    print(f"함수 외부: {my_num}, 주소: {id(my_num)}")

    # 결과: 함수 외부의 my_num은 여전히 10이며, 내부와 외부의 주소는 달라짐
```
